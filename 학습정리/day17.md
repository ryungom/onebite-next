# ⚡️ 한입 Next 강의 정리

## 열 일곱번째 날

### 리뷰 재검증 구현하기
- 이전대로 작성하면 새로고침을 눌러야지 데이터가 업데이트된것을 볼 수 있었음
- 성공적으로 submit이 완료되었을때, 서버에서 다시 리랜더링을 할 수 있게끔 해야함.
- next에서 제공하는 revalidatePath(현재 페이지 경로) 넣어주면 됌. 이 경로에 해당하는 페이지를 재검증하게 됌.
  - next 서버측에 재검증을 요청하도록 해주게 됌.
  - 데이터페칭, 컴포넌트들도 모두 리랜더링이 됌.
  - 주의점
     1. 오직 서버측에서만 호출할 수 있음. 클라이언트 호출 불가
     2. 해당페이지를 새롭게 불러와지면서 해당 페이지에 있는 모든 캐시들도 무효화 시키게 됌. ex) force-cache 또한 삭제됨.
     3. 해당 페이지에 해당되는 풀라우트 캐시에는 재업데이트 되지 않됌. 그렇기에 사실상 기존 풀라우트 캐시는 무효화, stale상태의 없는거나 마찬가지인 캐시가 되어버림. -> 새로고침하면 다이나믹으로 새롭게 데이터를 가져와서 업데이트 생성.
  - ![image](https://github.com/user-attachments/assets/217f0d25-bfc3-4754-a290-30e3b4477b83)
    - 이렇게 revalidatePath가 동작하는 이유 : 무조건 최신의 데이터를 보장하기 위해서. 

### 다양한 재검증 방식
- revalidatePath는 5가지 방식이 지원됌
  ```javascript
  //1. 특정 주소의 해당하는 페이지만 재검증
  revalidatePath(`/book/${bookId}`);

  //2. 특정 경로의 모든 동적 페이지를 재검증. 폴더경로 넣어줘야함
  revalidatePath(`/book/[id]`,'page');

  //3. 특정 레이아웃을 갖는 모든 페이지 재검증. 마찬가지로 폴더경로 넣어줘야함
  revalidatePath(`/(with-searchbar)`,'layout');

  //4. 모든 데이터 재검증
  revalidatePath('/',layout);

  //5. 태그기준 데이터캐시 재검증 **(스펠링다름!!!)**
  revalidateTag(`review-${bookId}`);

  // 이 태그 기준을 써먹으려면 데이터 캐싱의 태그옵션을 넣어야 함
  ...
  { next: { tags: [`review-${bookId}`] } }
- 위에서 태그기준으로 데이터캐시 재검증이 가장 효율이 좋음. 왜냐하면 1~4번은 굳이 필요없는 모든 데이터페칭의 데이터 캐시를 제거하기 때문에, 페이지별로, 레이아웃별로 다시 재검증이 필요한게 아니라면 가능하면 태그기준 데이터 캐시 재검증이 훨씬 더 좋음.

---
### 느낀점
- 
