# ⚡️ 한입 Next 강의 정리

## 열 세번째 날

### 풀 라우트 캐시 (Full Route Cache)
- Next 서버측에서 빌드타임에 특정 페이지의 랜더링 결과를 캐싱하는 기능. 페이지 캐시라고 불리기도 함.
- 정적 페이지로 만들어진 페이지에만 풀 라우트 캐시가 적용됌 
  - **서버 컴포넌트에만 설정됌. 클라이언트 컴포넌트는 페이지 유형에 영향 ㄴㄴ**
  - ![image](https://github.com/user-attachments/assets/bdd88e7d-e521-4b7d-bf59-e4c619b86571)
  - 동적페이지로 설정되는 기준 : 특정 페이지가 접속 요청 받을때마다 변화가 생기거나 데이터가 달라질 경우
    - 캐시안되는 Data Fetching을 사용, 동적 함수(쿠키, 헤더, 쿼리스트링)을 사용하는 컴포넌트가 존재할때
  - 정적페이지는 기본 default값으로 !동적페이지 라고 생각하면 됌.
  - 테이블로 구분
    -  ![image](https://github.com/user-attachments/assets/36e1c1d4-8a63-4bba-86a9-77620368771b)
- 가능하면 많은 페이지들을 풀 라우트 캐시가 적용되는 정적인 페이지로 만드는것을 권장.
- 동적인페이지는 절대로 안티패턴이 아님.
- 동적인 페이지는 데이터캐시를 이용해서 페이지를 빨리 적용되게 할 수 있음.
- 풀 라우트 캐시도 revalidate가 가능함. 해당 페이지에서 어떠한 컴포넌트라도 데이터 페칭에 revalidate가 포함되어 있으면 데이터 캐시뿐 아니라 페이지 캐시에도 Stale, fresh한 값이 적용됌.
  - ![image](https://github.com/user-attachments/assets/cede56fa-2a2d-4844-9ae7-05ac10e39051)
- 쿼리스트링은 빌드타임에 절대로 존재할 수 없음. 알 수 없으니까...
  - 서버컴포넌트에서 클라이언트 컴포넌트를 랜더링 할 때 사전랜더링에서 제외시키려면 <Suspense>컴포넌트로 감싸주면 됌.
  - useSearchParams는 비동기로 작업되는 hook.
- 쿼리스트링을 사용하는 페이지는 부득이하게 어쩔 수 없이 동적페이지가 되어서 풀 라우트 캐시를 이용하지 못하게 되지만, cache:"force-cache" 옵션을 데이터페칭에 넣어서 검색한 결과들에 한해서는 계속 캐싱데이터가 쌓이게끔 만들 수는 있음.
- 동적페이지 중 params를 사용하는 페이지는 generateStaticParams 함수로 동적경로를 미리 설정 가능.
  - 페이지라우터의 getStaticPaths랑 같은 기능. 
  - 단 generateStaticParams 사용하면 이 페이지에서 데이터 페칭의 데이터캐시값이 있더라도 무조건 해당 페이지는 풀라우트 캐시가 적용되는 동적인 페이지로 변환됌.
  - 그렇기에 따로 정적으로 만들어놓지 않은 페이지는 실시간으로 다이나믹 페이지로 만들어지기 때문에 접속하는 즉시 풀라우트캐시로 만들어짐.
- 404페이지로 넘어가게 하려면 최상단에서 not-found 파일을 만들어주고 데이터 호출시 status === 404 조건문을 넣어주면 됌
- 만약 정적으로 설정해둔 params외에 404로 보내버리고 싶을 경우?
  - dynamicParams 값을 false로 설정해두고 export 해두면 됌. 



---
### 느낀점
- 역시... on-demend ISR 방식으로 앱라우터에서 사용하려면 이 '풀 라우트 캐시'방법을 썼어야 했다. 페이지라우터에서 사용되었던 심화된 SSG 방식의 쓰임이 궁금했는데 이번 강의를 들으면서 궁금증이 해결되었다. 특히 모건님과 같이 프로젝트 하면서 serchParams 오류가 있었는데 그 해결방법이 이번 강의에 나왔어서 정말 신기했다. 서스펜스를 달아줘야 했다...
