# ⚡️ 한입 Next 강의 정리

## 열 다섯번째 날

### 스트리밍 - 컴포넌트 스트리밍
- 페이지 단위가 아닌 컴포넌트 단위로 스트리밍 적용하는 방법
- 기존 loading을 이용하는건 세세한 스트리밍은 불가능 함.
- 사용방법 : 스트리밍을 적용할 파일을 비동기 호출로 감싼다
- 다만 기존 방법처럼 따로 조작하지 않으면 쿼리스트링 문제는 동일하게 발생(로딩 fallback이 발생하지 않음)
  - suspense에 key값을 설정하여, useEffect의 의존성 배열처럼 쿼리스트링 값을 넣어주면 됌.
- suspense 컴포넌트 안에 데이터 페칭이 존재해야 함.
- 대부분 로딩파일보단 이 suspense가 더 많이 사용 됌.

### 스켈레톤 ui 만들기
- 빈배열을 만들고 매개변수 count 로 받아온 number만큼 새롭게 매핑하는 법
  - ```javascript
    new Array(count)
      .fill(0)
      .map((_, idx) => (
        <스켈컴포넌트 key={키값}/>
      ))
      ```
    - 매핑에서 인덱스만 필요하고 배열 돌리는 아이템이 필요 없으면 첫번째 인자에 언더스코어 (_)를 넣어두면 됌.
- React Loading skeleton : 애니메이션이 있는 리액트 스켈레톤 라이브러리

### 에러핸들링
- 지금까지는 try, catch 구문으로 에러핸들링 진행.
  - 이런 방식은 일일히 모든 데이터 페칭마다 구분을 해줘야 하고 신경써줘야하는 점도 많음
- 넥스트에서는 한꺼번에 에러 핸들링 잡을 수 있는 방법 제안.
  - 같은경로 혹은 같은 폴더위치에 error.tsx 파일을 만들고 그 안에 Error 컴포넌트 만들어주고, client 컴포넌트로 만들면 됌.
  - client 컴포넌트로 만드는 이유는 서버든 클라든 모두 함께 대응하기 위해서.
- 에러메세지를 받고 싶으면 {error} 를 받으면 됨. 타입은 Error. (자바스크립트 에러객체)
  - 두번째 인자로 reset 함수도 받는데 (타입은 void) 버튼으로 클릭이벤트 연결하면 다시 랜더링 할 수 있게끔 함.
  - 클라이언트 쪽에서만 받은 데이터를 이용해서 화면만 랜더링 하는것뿐. 그래서 서버컴포넌트까지 다시 랜더링 하게는 안함. 데이터패칭 수행ㄴㄴ
  - 클라이언트 컴포넌트에서만 발생한 오류만 호출.
  - 즉 새로고침하는것이 해결방안이므로, 그리고 클라이언트 컴포넌트라 window.location.reload()로 강제 새로고침 시행.
    - 다만 이러면 모든것이 새롭게 다시 리랜더링 하는것이므로 우아한 방법은 아님.
  - useRouter 내의 refresh()를 설정 후 reset()을 시행해주면 서버 + 클라이언트 초기화가 깔끔하게 이루어지게 됌.
    - 이 refresh()는 현재 페이지에 존재하는 모든 서버컴포넌트들을 서버측에서 다시 실행할 수 있게 해주는 메서드.
    - reset()은 에러상태를 초기화 시켜주는 기능도 있음.
    - 근데 여기서 refresh는 비동기로 작업되는 메서드. 다만 await가 이 메서드에 영향을 못줘서 동기적으로 못만듦.
    - startTransition(콜백함수) : 안에 함수들을 차례적으로 동기적 실행시켜주는 React 18ver.에 새로 추가된 함수.
- 에러 컴포넌트를 앱폴더 바로 하단에 냅두게 되면 레이아웃까지는 보여지지 않음. 따라서 레이아웃까지 살리기 위해서는 최상위 말고도 컴포넌트 곳곳까지 에러컴포넌트들을 잘 배치 해줘야 함.
- 
---
### 느낀점
- 데이터 페칭 대기를 위한 스트리밍과 스켈레톤에 대해서 잘 알게 되었다. suspense의 역활이 정말 중요했구나 싶다. 빨리 챌린지 과제랑 현재 작업중인 프로젝트에도 넣어보고 싶다!!
